<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/src/style/style.css" />
    <title>Bololo</title>
</head>

<body>
    <div id="game-container">

        <div id="start-screen">
        <h1>É o Grau</h1>
        <h2>Passe seu tempo na tocada, vai ser só tapa no vento.</h2>
        <button id="start-button">Vamo Cachorro!</button>
        </div>

        <div id="info-panel">
        <div>
            <span>Pontuação: </span>
            <span id="score">0</span>
        </div>
        <div>
            <span>Velocidade: </span>
            <span id="speed">0</span>
            <span> km/h</span>
        </div>
        <div>
            <span>Ângulo do Wheelie: </span>
            <span id="wheelie-angle">0</span>
            <span>°</span>
        </div>
        <div>
            <div class="meter">
            <div id="wheelie-meter" class="meter-fill" style="width: 0%;"></div>
            </div>
        </div>
        <div class="chances">
            <div class="chance-indicator"></div>
            <div class="chance-indicator"></div>
            <div class="chance-indicator"></div>
        </div>
        <div class="controls">
            <p><strong>Controles:</strong></p>
            <p>↑ - Acelerar | ↓ - Frear | ← - Empinar | → - Voltar ao normal</p>
        </div>
        </div>

        <div id="game-over">
        <h2>Game Over!</h2>
        <p>Você caiu 3 vezes!</p>
        <p>Pontuação final: <span id="final-score">0</span></p>
        <button id="restart-button">Jogar Novamente</button>
        </div>
    </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    document.getElementById('start-button').addEventListener('click', () => {
      document.getElementById('start-screen').style.display = 'none';
      initGame();
    });

    function initGame() {
        // Elementos da UI
        const scoreElement = document.getElementById('score');
        const speedElement = document.getElementById('speed');
        const wheelieAngleElement = document.getElementById('wheelie-angle');
        const wheelieMeter = document.getElementById('wheelie-meter');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreElement = document.getElementById('final-score');
        const chanceIndicators = document.querySelectorAll('.chance-indicator');
        
        // Variáveis do jogo
        let wheelieAngle = 0;
        let speed = 0;
        let score = 0;
        let gameStarted = true;
        let chancesLeft = 3;
        let isGameOver = false;
        
        // Função para reiniciar o jogo
        document.getElementById('restart-button').addEventListener('click', () => {
            // Recarrega a página completamente
            window.location.reload();
        });
        
        // Função para verificar queda
        const checkCrash = () => {
            if (wheelieAngle > 60) {
                chancesLeft--;
                chanceIndicators[3 - chancesLeft - 1].classList.add('chance-lost');
                
                // Reset após queda
                wheelieAngle = 0;
                speed *= 0.5; // Reduz a velocidade pela metade após a queda
                
                if (chancesLeft <= 0) {
                    isGameOver = true;
                    gameStarted = false;
                    finalScoreElement.textContent = Math.floor(score);
                    gameOverScreen.style.display = 'block';
                }
            }
        };
        
        // Configuração do Three.js
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x339fff); // Céu azul
        
        const container = document.getElementById('game-container');
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        // Câmera
        const camera = new THREE.PerspectiveCamera(70, width / height, 0.1, 1000);
        camera.position.set(0, 2, 8);
        camera.lookAt(0, 0, 0);
        
        // Renderizador
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        container.appendChild(renderer.domElement);
        
        // Redimensionar quando a janela mudar
        window.addEventListener('resize', () => {
            const newWidth = container.clientWidth;
            const newHeight = container.clientHeight;
            
            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            
            renderer.setSize(newWidth, newHeight);
        });
        
        // Iluminação
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7);
        scene.add(directionalLight);
      
        // Chão (pista)
        const groundGeometry = new THREE.PlaneGeometry(800, 20);
        const groundTexture = new THREE.TextureLoader().load('/api/placeholder/20/20');
        groundTexture.wrapS = THREE.RepeatWrapping;
        groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set(2, 8);
        
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x333333,
            roughness: 0.8,
            map: groundTexture
        });
        
        // Criar múltiplos segmentos de chão
        const groundSegments = [];
        const numGroundSegments = 10;
        const groundSegmentWidth = 20;

        for (let i = 0; i < numGroundSegments; i++) {
            const groundSegment = new THREE.Mesh(groundGeometry, groundMaterial);
            groundSegment.rotation.x = -Math.PI / 2;
            groundSegment.position.set(i * groundSegmentWidth, -0.5, 0);
            scene.add(groundSegment);
            groundSegments.push(groundSegment);
        }
        
        // Criar linhas na pista
        const roadLineGeometry = new THREE.PlaneGeometry(3, 0.2);
        const roadLineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        
        const roadLines = [];
        const numLines = 20;
        const lineSpacing = 20;
        
        for (let i = -1; i < numLines; i++) {
            const line = new THREE.Mesh(roadLineGeometry, roadLineMaterial);
            line.rotation.x = -Math.PI / 2;
            line.position.set(i * lineSpacing, -0.48, 0);
            scene.add(line);
            roadLines.push(line);
        }

        // Criar cerca na lateral da pista
        const fenceSegments = [];
        const numFenceSegments = 20;
        const fenceSpacing = 20;

        // Criar postes da cerca
        const postGeometry = new THREE.BoxGeometry(0.2, 1.5, 0.2);
        const postMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Marrom
        
        // Criar barras horizontais da cerca
        const railGeometry = new THREE.BoxGeometry(fenceSpacing, 0.1, 0.1);
        const railMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Marrom

        // Criar segmentos da cerca (cada segmento tem um poste e duas barras horizontais)
        for (let i = -1; i < numFenceSegments; i++) {
            const fenceGroup = new THREE.Group();
            
            // Adicionar poste
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.set(0, 0.75, 0); // Metade da altura do poste
            fenceGroup.add(post);
            
            // Adicionar barras horizontais
            const upperRail = new THREE.Mesh(railGeometry, railMaterial);
            upperRail.position.set(fenceSpacing/2, 1.2, 0);
            fenceGroup.add(upperRail);
            
            const lowerRail = new THREE.Mesh(railGeometry, railMaterial);
            lowerRail.position.set(fenceSpacing/2, 0.4, 0);
            fenceGroup.add(lowerRail);
            
            // Posicionar o segmento da cerca
            fenceGroup.position.set(i * fenceSpacing, -0.5, -10); // 10 unidades para o lado da pista
            scene.add(fenceGroup);
            fenceSegments.push(fenceGroup);
        }
      
        // Criar a moto
        const motoGroup = new THREE.Group();
        scene.add(motoGroup);
        
        // Quadro detalhado da moto
        const frameGroup = new THREE.Group();
        
        // Tubo principal
        const mainTubeGeometry = new THREE.CylinderGeometry(0.1, 0.1, 2, 16);
        const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x010000 });
        const mainTube = new THREE.Mesh(mainTubeGeometry, frameMaterial);
        mainTube.rotation.z = Math.PI / 2;
        mainTube.position.set(0, 0.6, 0);
        frameGroup.add(mainTube);

        // Tubo superior
        const topTubeGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.6, 16);
        const topTube = new THREE.Mesh(topTubeGeometry, frameMaterial);
        topTube.position.set(-0.4, 0.4, 0);
        topTube.rotation.set(0, 0, Math.PI / 4);
        frameGroup.add(topTube);

        // Tubo inferior
        const bottomTubeGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.9, 16);
        const bottomTube = new THREE.Mesh(bottomTubeGeometry, frameMaterial);
        bottomTube.position.set(0.54, 0.6, 0);
        bottomTube.rotation.set(0, 0, -Math.PI / 6);
        frameGroup.add(bottomTube);

        // Suporte do motor
        const motorSupportGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.54, 16);
        const motorSupport = new THREE.Mesh(motorSupportGeometry, frameMaterial);
        motorSupport.position.set(0.08, 0.22, 0);
        motorSupport.rotation.z = Math.PI / 2;
        frameGroup.add(motorSupport);

        motoGroup.add(frameGroup);
        
        // Guidão
        const handlebarGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1);
        const handlebarMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const handlebar = new THREE.Mesh(handlebarGeometry, handlebarMaterial);
        handlebar.rotation.x = Math.PI / 2;
        handlebar.position.set(0.75, 1, 0);
        motoGroup.add(handlebar);
        
        // Rodas
        const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.2, 12);
        
        // Criar gradient map para as rodas
        const gradientTexture = new THREE.DataTexture(new Uint8Array([
            0, 0, 0,      // Preto
            40, 40, 40,   // Cinza escuro
            80, 80, 80,   // Cinza médio
            100, 100, 100 // Cinza claro
        ]), 4, 1, THREE.RGBFormat);
        gradientTexture.needsUpdate = true;

        const wheelMaterial = new THREE.MeshToonMaterial({ 
            color: 0x333333, gradientTexture,
            shininess: 1
        });
        
        const frontWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
        frontWheel.rotation.x = Math.PI / 2;
        frontWheel.position.set(0.8, 0, 0);
        motoGroup.add(frontWheel);
        
        const backWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
        backWheel.rotation.x = Math.PI / 2;
        backWheel.position.set(-0.8, 0, 0);
        motoGroup.add(backWheel);
        
        // Piloto
        const riderBodyGeometry = new THREE.BoxGeometry(0.5, 0.8, 0.3);
        const riderHeadGeometry = new THREE.SphereGeometry(0.2, 16, 16);
        const riderMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
        
        const riderBody = new THREE.Mesh(riderBodyGeometry, riderMaterial);
        riderBody.position.set(0, 1.1, 0);
        motoGroup.add(riderBody);
        
        const riderHead = new THREE.Mesh(riderHeadGeometry, riderMaterial);
        riderHead.position.set(0.1, 1.6, 0);
        motoGroup.add(riderHead);
        
        // Fogo do escapamento
        const createExhaust = () => {
            const exhaustGeometry = new THREE.ConeGeometry(0.1, 0.3, 8);
            const exhaustMaterial = new THREE.MeshBasicMaterial({ 
            color: new THREE.Color(Math.random() < 0.5 ? 0xff5500 : 0xff8800)
            });
            
            const exhaust = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
            exhaust.position.set(-1.2, 0.6, 0);
            exhaust.rotation.z = Math.PI / 2;
            motoGroup.add(exhaust);
            
            // Animar e remover o fogo
            setTimeout(() => {
            motoGroup.remove(exhaust);
            }, 100);
        };
        
        // Posicionar a moto
        motoGroup.position.set(0, 0, 0);
        
        // Estado dos controles
        const keyState = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false
        };
        
        // Manipulação de eventos do teclado
        window.addEventListener('keydown', (e) => {
            if (keyState.hasOwnProperty(e.key)) {
            keyState[e.key] = true;
            }
        });
        
        window.addEventListener('keyup', (e) => {
            if (keyState.hasOwnProperty(e.key)) {
            keyState[e.key] = false;
            }
        });
        
        // Atualização da física
        const updatePhysics = () => {
            if (isGameOver) return;
            
            // Aceleração
            if (keyState.ArrowUp) {
                // Quanto maior o ângulo do wheelie, mais rápido acelera
                const accelerationMultiplier = 1 + (wheelieAngle / 60) * 1.5;
                if (speed < 120) speed += 1 * accelerationMultiplier;
                if (speed > 60 && Math.random() < 0.3) createExhaust();
            }
            
            // Verificar queda após atualizar o ângulo
            checkCrash();
            
            // Freio
            if (keyState.ArrowDown) {
                // Quanto maior o ângulo do wheelie, mais difícil frear
                const brakeMultiplier = 1 - (wheelieAngle / 60) * 0.5; // Mínimo de 0.5x a força do freio
                if (speed > 0) speed -= 2 * brakeMultiplier;
                else speed = 0;
            }
            
            // Empinar
            if (keyState.ArrowLeft && speed > 20) {
                if (wheelieAngle < 60) wheelieAngle += 1;
            }
            
            // Baixar
            if (keyState.ArrowRight) {
                if (wheelieAngle > 0) wheelieAngle -= 2;
                else wheelieAngle = 0;
            }
            
            // Gravidade natural para baixar a moto
            if (!keyState.ArrowLeft && wheelieAngle > 0) {
                wheelieAngle -= 1.2;
                if (wheelieAngle < 0) wheelieAngle = 0;
            }
            
            // Desacelerar naturalmente
            if (!keyState.ArrowUp && !keyState.ArrowDown) {
                // Quanto maior o ângulo do wheelie, menos desacelera naturalmente
                const dragMultiplier = 1 - (wheelieAngle / 60) * 0.5; // Mínimo de 0.5x o arrasto
                speed *= 0.98 + (1 - dragMultiplier) * 0.01;
            }
            
            // Atualizar a interface do usuário
            scoreElement.textContent = Math.floor(score);
            speedElement.textContent = Math.floor(speed);
            wheelieAngleElement.textContent = Math.floor(wheelieAngle);
            wheelieMeter.style.width = `${(wheelieAngle / 60) * 100}%`;
            
            // Calcular pontuação
            if (wheelieAngle > 22 && speed > 60) {
            score += (wheelieAngle * speed) / 5000;
            }
        };
        
        // Rotação das rodas
        const wheelRotationSpeed = 0.01;
        
        // Função de animação
        const animate = () => {
            if (!gameStarted) return;
            
            requestAnimationFrame(animate);
            
            updatePhysics();
            
            // Mover a moto para frente com base na velocidade
            motoGroup.position.x += speed * 0.01;
            
            // Aplicar o ângulo de wheelie e ajustar altura
            motoGroup.rotation.z = wheelieAngle * (Math.PI / 180);
            
            // Calcular a altura baseada no ângulo de wheelie
            // Quanto maior o ângulo, mais alto a moto sobe
            const heightOffset = (wheelieAngle / 60) * 0.6; // 0.8 é a altura máxima
            motoGroup.position.y = heightOffset;
            
            // Rotacionar as rodas com base na velocidade
            frontWheel.rotation.y += wheelRotationSpeed * speed;
            backWheel.rotation.y += wheelRotationSpeed * speed;
            
            // Reciclar segmentos do chão
            const resetGroundDistance = groundSegmentWidth * numGroundSegments;
            groundSegments.forEach((segment) => {
                if (motoGroup.position.x - segment.position.x > groundSegmentWidth * 2) {
                    segment.position.x += resetGroundDistance;
                }
            });
            
            // Reciclar linhas da estrada
            const resetDistance = lineSpacing * numLines;
            roadLines.forEach((line) => {
                if (motoGroup.position.x - line.position.x > 30) {
                    line.position.x += resetDistance;
                }
            });

            // Reciclar segmentos da cerca
            const resetFenceDistance = fenceSpacing * numFenceSegments;
            fenceSegments.forEach((fence) => {
                if (motoGroup.position.x - fence.position.x > fenceSpacing * 2) {
                    fence.position.x += resetFenceDistance;
                }
            });
            
            // Ajustar a câmera para seguir a moto
            camera.position.x = motoGroup.position.x - 2;
            camera.lookAt(motoGroup.position.x + 3, 1, 0);
            
            renderer.render(scene, camera);
        };
        
        // Iniciar animação
        animate();
    }
  </script>
</body>
</html>